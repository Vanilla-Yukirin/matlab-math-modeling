clc;clear;
% 计算斐波那契数列第N项模p的值
N=1;
p=10000;
% 递推关系：F(i) = F(i-1) + F(i-2)
tic
A1 = 1; % F(1)，即前一项 -> 在迭代过程中代表F(i-1)
A2 = 1; % F(2)，即当前项 -> 在迭代过程中代表F(i)
for i=3:N % 然后这里只需要从第3项开始迭代，每次迭代生成第i项
    t=A2; % 临时存储一下当前项A2，其在下一轮会变成前一项A1
    A2=mod(A1+A2,p); % 递推出新的一项，并取模防止溢出
    A1=t; % 将原来的当前项作为下一轮的前一项
end
result=A2; % F(N)
disp(result);
toc


%% 递归函数写法
p=1000;
tic;
fib(50,p)
toc

%% 另外一种方法 矩阵快速幂
% 不要求掌握，感兴趣自学即可
clc;clear;
% 计算斐波那契数列第N项模p的值
N=uint64(100000000);
p=uint64(10000);
tic
A=uint64([1 1;1 0]);
% A^n=[F(n+1) F(n); F(n) F(n-1)]
result=uint64(eye(2)); % 单位矩阵
n=N-1;
mul_mod = @(X, Y) [ ...
    mod(X(1,1)*Y(1,1) + X(1,2)*Y(2,1), p), mod(X(1,1)*Y(1,2) + X(1,2)*Y(2,2), p); ...
    mod(X(2,1)*Y(1,1) + X(2,2)*Y(2,1), p), mod(X(2,1)*Y(1,2) + X(2,2)*Y(2,2), p) ...
]; % 手动构建uint64的矩阵乘法
% disp(uint64(1)/2) % 这玩意居然是四舍五入的:(
while n>0
    if mod(n,2)==1
        result=mul_mod(result,A);
    end
    A=mul_mod(A,A);
    % n=floor(n/2);
    n=bitshift(n,-1);
end
disp(result(1,1));
toc

%% 推荐阅读：https://oi-wiki.org/math/combinatorics/fibonacci/